syntax = "proto3";
package micelio;

option go_package = "micelio/pkg/proto";

// Envelope wraps every message on the wire.
// msg_type is numeric for extensibility: core 1-99, plugin 1000+.
message Envelope {
    string message_id   = 1;     // UUID v4, unique per message
    string sender_id    = 2;     // node_id of originator
    uint64 lamport_ts   = 3;     // Lamport clock (reserved, unused in Phase 2)
    uint32 hop_count    = 4;     // decremented at each hop
    uint32 msg_type     = 5;     // payload type
    bytes  payload      = 6;     // serialized inner message
    bytes  signature    = 7;     // ED25519 signature (excludes hop_count and sender_pubkey)
    bytes  sender_pubkey = 8;    // raw 32-byte ED25519 public key of originator
}

// PeerHello is sent by the initiator after the Noise handshake.
message PeerHello {
    string node_id        = 1;
    string version        = 2;
    repeated string tags  = 3;
    bool reachable        = 4;
    string listen_addr    = 5;
    bytes ed25519_pubkey  = 6;   // raw 32-byte ED25519 public key
}

// PeerHelloAck is the responder's reply to PeerHello.
// Wire format is identical to PeerHello; msg_type=2 distinguishes it.
// Implementations MUST serialize/deserialize as PeerHello on the wire.
message PeerHelloAck {
    string node_id        = 1;
    string version        = 2;
    repeated string tags  = 3;
    bool reachable        = 4;
    string listen_addr    = 5;
    bytes ed25519_pubkey  = 6;
}

// ChatMessage is a partyline chat message.
message ChatMessage {
    string nick      = 1;
    string text      = 2;
    uint64 timestamp = 3;
}

// PeerInfo describes a known peer for exchange.
message PeerInfo {
    string node_id        = 1;
    string addr           = 2;
    bool   reachable      = 3;
    bytes  ed25519_pubkey = 4;
    uint64 last_seen      = 5;
}

// PeerExchange carries a list of known peers (msg_type=4).
message PeerExchange {
    repeated PeerInfo peers = 1;
}

// StateEntry represents a single key-value pair with LWW metadata.
// Each entry is self-authenticating: it carries the author's ED25519 public key
// and a signature over all semantic fields. Nodes verify before accepting.
message StateEntry {
    string key           = 1;
    bytes  value         = 2;
    uint64 lamport_ts    = 3;  // per-entry Lamport clock
    string node_id       = 4;  // originator node_id = sha256(author_pubkey)
    bool   deleted       = 5;  // tombstone marker for soft-delete
    bytes  signature     = 6;  // ED25519 signature over (key, value, lamport_ts, node_id, deleted)
    bytes  author_pubkey = 7;  // raw 32-byte ED25519 public key of author
}

// StateUpdate carries a single state change (msg_type=6, gossip-relayed).
message StateUpdate {
    StateEntry entry = 1;
}

// StateSyncRequest asks a peer for state entries it is missing (msg_type=7, direct).
// The known map is a version vector: for each nodeID, the highest lamport_ts
// the requester already has. The responder sends only entries newer than this.
// An empty map means "send everything" (fresh node).
message StateSyncRequest {
    map<string, uint64> known = 1;
}

// StateSyncResponse carries the delta state entries (msg_type=8, direct).
message StateSyncResponse {
    repeated StateEntry entries = 1;
}
